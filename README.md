# Monadic_parser

библиотека текстового анализа.
Написан с целью возможной минимизации кода требуемого для создания парсеров.

использование
Maybe<T> run_parser(const parser_type<T> &parser, const char *input)
запускает процесс разбора. parser - функция разбора, input - поток текстовых данных

Возвращает объект Maybe<T>, имеющий следующий интерфейс:
operator bool() - проверяет что содержит полезные данные
T* get() - возвращает указатель на содержащиеся данные
const std::string& getMessage() - возвращает сообщение об ошибке если не содержит полезных данных

Функция разбора определена следующим образом:
using parser_type = std::function<parser_out<T>(parsing_state)>, где
using parser_out = std::pair<std::unique_ptr<T>, parsing_state>;

Эта функция имеет сигнатуру 
  state -> (state, T)
то есть принимает состояние и возвращает пару новое состояние и произвольный объект класса T

Функция разбора может быть определена одним из трех способов:
определить функциональную константу в виде лямбды
parser_type<T> p_name{[](parsing_state ps){...}}; //см например, константу any_char

определить функцию возвращающую лямбду
parser_type<T> p_name(Args... args)
{
  return {[&](parsing_state ps){...}};
}

определить напрямую функцию разбора
parsing_out<T> p_name(parsing_state ps)
{
  ...
}

константа используется через свой идентификатор напрямую
auto result = run_parser( p_const, "text" );
функция возвращающая лямбду - через стандартный вызов
auto result = run_parser( p_function(args...), "text");
сырая функция - через обертку function:
auto result = run_parser( function(p_raw), "text");

состояние parsing_state состоит из класса-обертки data_stream, содержащего бегущий указатель на текущую позицию разбора, а так-же позицию в тексте для отображения сообщения об ошибке
, а так-же специальной структуры parsing_fault_data, содержащей данные о том, валиден ли парсер, описание места и причины возникновения ошибки, точку возникновения ошибки
интерфейс состояния:
конструктор parsing_state(const data_stream& ds, const parsing_fault_data &pfd), который может быть полезен в ряде случаев если необходимо вручную согласовать состояния
bool is_valid() - возвращает true если цепочка разбора вернувшая данное состояние была успешна и содержит полезные значения. Иначе содержит сообщение об ошибке
void fault(const std::string& why, bool ass_ds) - делает состояние невалидным и записывает указанную строку в качестве причины. ass_ds - добавлять или нет в строку текущую позицию

Полезные данные содержатся в виде умного указателя unique_ptr<T>.

Использование возможно одним из двух способов: низкоуровневый разбор и высокоуровневый.
Низкоуровневый предполагает следующий процесс:
1) берем некий готовый парсер и вызываем его с текущим состоянием. Получаем на выходе parser_out<T>, содержащий новое состояние и возможно, умный указатель с результатом разбора.
2) проверяем состояние, обратившись к нему через функцию .second.is_valid()
  если состояние невалидно - можем вернуть непосредственно текущий parser_out<T>, либо выполнить некие другие действия по желанию.
  если состояние валидно - можем обновить текущее состояние полученным, присвоив ps = out.second;, либо выполнив некие другие действия.
  после новым состоянием вызываем следующие по цепочке парсеры.
3) в конце требуется сформировать объект parser_out<T> посредством списка инициализации, в который в первый аргумент передается unique_ptr<T> с выходным значением, а во второй - последнее актуальное состояние.
Если разбор неуспешен - в качестве состояния нужно вернуть состояние из выхода того парсера, при выполнении которого возникла ошибка, а в качестве значения - пустой unique_ptr<T>
Если успешен - в качестве значения либо передаем сформированную переменную посредством make_unique<T>, либо напрямую состояние из выхода какого либо парсера через move(out.first)

Низкоуровневый разбор рекомендуется только в ситуациях когда адекватный разбор невозможно составить из готовых парсеров, так как предполагает написание сравнительно большого объема кода.

Высокоуровневый разбор предполагает быстрое и удобное составление сложных парсеров из более простых, для чего существует набор готовых парсеров и функциональный интерфейс их объединения.
Готовые парсеры включают в себя:
parser_type<char> p_char(const char &t) - возвращает парсер, ожидающий на вход конкретный символ
parser_type<char> p_char(const function<bool(char)> &predicate, const std::string &description) - принимает функцию char -> bool и строку-описание что ожидается от ввода (для отображения в сообщениях об ошибке)
parser_type<std::string> many(const parser_type<char> &subparser) - принимает символьный парсер и парсит строку из подряд идущих символов удовлетворяющих ему. Никогда не возвращает ошибку. При отсутствии символов удовлетворяющих подпарсеру возвращает пустую строку.
parser_type<std::string> many1(const parser_type<char> &subparser) - тоже самое но падает если ни одного символа удовлетворяющего подпарсеру нет.

parser_type<std::vector<T>> many(const parser_type<T> &subparser) - принимает подпарсер и парсит массив из подряд идущих объектов удовтелворяющих ему. При отсутствии совпадений возвращает пустой массив.
parser_type<std::string> p_string(const std::string &s) - ожидает на входе заданную строку. При совпадении возвращает её-же.

parser_type<std::string> p_until(const parser_type<T> &subparser) - принимает подпарсер и возвращает строку символов из ввода до тех пор пока не будет удовлетворен подпарсер.
parser_type<char> any_char - возвращает текущий символ. Падает на конце ввода.

Операции объединения включают в себя:
функтор - специальную функцию operator/, принимающую функцию и парсер. Возвращает новый парсер, значение которого было обработано переданной функцией.
Пример: 
Пусть есть функция function<float(int)> int_sqrt([](int x){return sqrt((float)x);});
парсер parser_type<int> parse_int
Тогда можно создать новый парсер который парсит целое число, а возвращает корень из него в одну операцию
parser_type<float> parse_int_and_sqrt = int_sqrt / parse_int;

аппликативный функтор operator*, позволяющий применить функцию нескольких переменных:
function<int(int, int, int)> add3([](int a, int b, int c){return a + b + c;});
parser_type<int> sum2 = add / parse_int * parse_int * parse_int;
Это - один из основных способов создания комбинированных сложных парсеров из совокупности простых.
достаточно создать функцию нескольких переменных, возвращающую целевой тип данных, и применить её совокупностью парсеров посредством функтора и аппликативных функторов.
В этом случае автоматически будут вызываться парсеры в нужной очередности и полученные ими данные будут переданы в функцию. При неудаче разбора на любом из этапов
будет автоматически сформировано информативное сообщение об ошибке.

монада operator>> - может быть использована одним из двух способов.
первый: принимает парсер типа Arg и функцию принимающую Arg и возвращающую парсер типа T. Возвращает парсер, который применяет функцию результатом работы первого парсера, и возвращает второй.
Весьма ограниченная по полезности функция из-за отсутствия удобных средств работы с монадами.

Второй способ - принимает два парсера, вызывая их по очереди и игнорируя возвращаемый результат первого. Полезна для создания парсеров, контролирующих наличие разных контрольных слов и символов.

Функция выбора operator||: принимает два парсера, пробует вызвать их по очереди. Возвращает результат первого успешно выполнившегося разбора.
Самая полезная функция, экономящая невероятные горы кода.

Простая демонстрация: парсер, выбирающий строку содержащую корректную запись целого числа. Целое число может содержать символ + или - а так-же последовательность цифр.

parser_type<char> p_digit = p_char([](char c){return isdigit(c);}, "digit");  //цифра
parser_type<string> p_digits = many1(p_digit);                                //последовательность цифр минимум 1 штука
parser_type<char> p_plus_or_minus = p_char('+') || p_char('-');               //символы + либо -
function char_add_string{[](char c, string s){return s.insert(0, 1, c);}};//функция вставляющая символ перед строкой
parser_type<string> p_int = (char_add_string / p_plus_or_minus * p_digits) || p_digits;
//результат - плюс или минус перед строкой цифр либо просто строка цифр.
